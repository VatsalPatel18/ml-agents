# core_tools/code_execution.py
import logging
import os
import time
import random
import subprocess
import json
from typing import Dict, Any

from google.adk.tools.function_tool import FunctionTool
from google.adk.tools.tool_context import ToolContext

# Import config and placeholders (though placeholder func isn't used directly)
from config import (
    WORKSPACE_DIR,
    ALLOW_INSECURE_CODE_EXECUTION,
    CODE_EXECUTION_TIMEOUT,
    tool_calls_logger # Use the configured logger
)
# from placeholders import execute_code_externally # We implement similar logic here

# --- SECURITY WARNING ---
# The following tool executes arbitrary Python code generated by an LLM
# using subprocess. This is **EXTREMELY DANGEROUS** and should **NEVER**
# be used in production environments without a robust sandboxing mechanism
# (e.g., Docker containers, gVisor, Firecracker, nsjail).
# Executing untrusted code can lead to severe security vulnerabilities,
# data breaches, and system compromise.
# Use this tool ONLY for local testing and development with extreme caution,
# and only if you understand and accept the risks involved.
# Ensure the ALLOW_INSECURE_CODE_EXECUTION flag in config.py is
# explicitly set to True to enable this tool.
# --- END SECURITY WARNING ---

@FunctionTool
def code_execution_tool(
    code_string: str,
    tool_context: ToolContext, # ADK context
    working_dir: str = WORKSPACE_DIR,
    timeout_seconds: int = CODE_EXECUTION_TIMEOUT
) -> Dict[str, Any]:
    """
    *** INSECURE TOOL *** Executes the provided Python code string in a subprocess.

    WARNING: This tool is highly insecure and executes arbitrary code.
    Use ONLY for local testing with trusted models and accept the risks.
    Requires ALLOW_INSECURE_CODE_EXECUTION=True in config.py.

    Args:
        code_string: The Python code to execute.
        tool_context: The ADK ToolContext.
        working_dir: The directory where code should run and files are saved. Defaults to WORKSPACE_DIR from config.
        timeout_seconds: Maximum execution time. Defaults to CODE_EXECUTION_TIMEOUT from config.

    Returns:
        Dictionary with:
            'status' ('success', 'error', 'disabled').
            'stdout' (captured standard output).
            'stderr' (captured standard error).
            'output_files' (dict mapping logical name from 'SAVED_OUTPUT:' convention -> absolute local path).
            'metrics' (dict parsed from 'METRICS:' convention, or None).
            'error_message' (string, if status is 'error' or 'disabled').
    """
    invocation_id = tool_context.invocation_id
    agent_name = tool_context.agent_name
    tool_calls_logger.info(f"INVOKE_ID={invocation_id}: Agent '{agent_name}' requested code execution.")

    if not ALLOW_INSECURE_CODE_EXECUTION:
        error_msg = "Insecure code execution is disabled in config.py (ALLOW_INSECURE_CODE_EXECUTION=False)."
        tool_calls_logger.error(f"INVOKE_ID={invocation_id}: {error_msg}")
        return {
            "status": "disabled",
            "stdout": "",
            "stderr": error_msg,
            "output_files": {},
            "metrics": None,
            "error_message": error_msg,
        }

    tool_calls_logger.warning(f"INVOKE_ID={invocation_id}: --- EXECUTING CODE INSECURELY using subprocess ---")
    tool_calls_logger.debug(f"INVOKE_ID={invocation_id}: Code:\n{code_string[:500]}...") # Log beginning of code

    os.makedirs(working_dir, exist_ok=True)
    # Use a more unique script name within the workspace
    script_filename = f"script_{invocation_id}_{int(time.time())}_{random.randint(10000, 99999)}.py"
    script_path = os.path.join(working_dir, script_filename)
    output_files = {}
    metrics = None
    stdout_res = ""
    stderr_res = ""
    status = "success" # Assume success initially
    error_message = None

    try:
        with open(script_path, "w", encoding="utf-8") as f:
            f.write(code_string)
        tool_calls_logger.debug(f"INVOKE_ID={invocation_id}: Wrote code to temporary script: {script_path}")

        # --- !!! INSECURE EXECUTION !!! ---
        process = subprocess.run(
            ["python", script_path], # Consider using a specific virtualenv python if needed
            capture_output=True,
            text=True,
            cwd=working_dir, # Run script from the workspace directory
            timeout=timeout_seconds,
            check=False, # Don't raise exception on non-zero exit code automatically
            env=os.environ.copy(), # Pass environment variables (consider restricting this)
        )
        # --- !!! END INSECURE EXECUTION !!! ---

        stdout_res = process.stdout
        stderr_res = process.stderr
        tool_calls_logger.debug(f"INVOKE_ID={invocation_id}: Subprocess finished. Exit Code: {process.returncode}")
        tool_calls_logger.debug(f"INVOKE_ID={invocation_id}: Stdout:\n{stdout_res}")
        if stderr_res:
             tool_calls_logger.debug(f"INVOKE_ID={invocation_id}: Stderr:\n{stderr_res}")


        if process.returncode != 0:
            status = "error"
            error_message = f"Code execution failed with exit code {process.returncode}."
            tool_calls_logger.error(f"INVOKE_ID={invocation_id}: {error_message}\nStderr: {stderr_res}")
        else:
            tool_calls_logger.info(f"INVOKE_ID={invocation_id}: Code execution seemingly succeeded (Exit Code 0).")
            # Parse stdout for conventions AFTER successful execution
            for line in stdout_res.splitlines():
                # Parse SAVED_OUTPUT: logical_name=/path/to/file.ext
                if line.startswith("SAVED_OUTPUT:"):
                    try:
                        name_path_str = line.split(":", 1)[1].strip()
                        name, path_str = name_path_str.split("=", 1)
                        name = name.strip()
                        path_str = path_str.strip()
                        # IMPORTANT: Resolve path relative to working_dir if it's not absolute
                        if not os.path.isabs(path_str):
                           abs_path = os.path.abspath(os.path.join(working_dir, path_str))
                        else:
                           abs_path = path_str # Assume it was generated absolute

                        # Basic check: ensure the resolved path exists and is within the workspace
                        if abs_path.startswith(os.path.abspath(working_dir)) and os.path.exists(abs_path):
                            output_files[name] = abs_path
                            tool_calls_logger.info(f"INVOKE_ID={invocation_id}: Detected output file via convention: '{name}' -> '{abs_path}'")
                        else:
                            tool_calls_logger.warning(f"INVOKE_ID={invocation_id}: Output path '{path_str}' reported but invalid or outside workspace. Absolute: '{abs_path}', Exists: {os.path.exists(abs_path)}")
                    except Exception as e:
                        tool_calls_logger.warning(f"INVOKE_ID={invocation_id}: Could not parse SAVED_OUTPUT line: '{line}' - Error: {e}")

                # Parse METRICS: {"accuracy": 0.95, ...}
                elif line.startswith("METRICS:"):
                    try:
                        metrics_json = line.split(":", 1)[1].strip()
                        metrics = json.loads(metrics_json)
                        tool_calls_logger.info(f"INVOKE_ID={invocation_id}: Parsed metrics via convention: {metrics}")
                        # Assume only one metrics line
                    except Exception as e:
                        tool_calls_logger.warning(f"INVOKE_ID={invocation_id}: Could not parse METRICS line: '{line}' - Error: {e}")

            # Fallback: List files actually present if no convention used (less reliable)
            # This might catch files saved without printing the convention, but lacks logical names.
            # Consider if this fallback is desirable or too noisy.
            # try:
            #     for item in os.listdir(working_dir):
            #         item_path = os.path.abspath(os.path.join(working_dir, item))
            #         if os.path.isfile(item_path) and item != script_filename:
            #             # Assign a generic name if not already detected via convention
            #             if item_path not in output_files.values():
            #                 logical_name = f"unreported_output_{len(output_files)}"
            #                 output_files[logical_name] = item_path
            #                 tool_calls_logger.info(f"INVOKE_ID={invocation_id}: Found additional unreported output file: '{logical_name}' -> '{item_path}'")
            # except Exception as e:
            #     tool_calls_logger.warning(f"INVOKE_ID={invocation_id}: Error listing workspace directory for fallback file detection: {e}")


    except subprocess.TimeoutExpired:
        status = "error"
        error_message = f"Code execution timed out after {timeout_seconds} seconds."
        stderr_res = error_message # Put timeout message in stderr field
        tool_calls_logger.error(f"INVOKE_ID={invocation_id}: {error_message}")
    except Exception as e:
        status = "error"
        error_message = f"Failed to execute script via subprocess: {e}"
        stderr_res = error_message # Put exception message in stderr field
        tool_calls_logger.error(f"INVOKE_ID={invocation_id}: {error_message}", exc_info=True)
    finally:
        # Attempt to clean up the temporary script file
        if os.path.exists(script_path):
            try:
                os.remove(script_path)
                tool_calls_logger.debug(f"INVOKE_ID={invocation_id}: Cleaned up temporary script: {script_path}")
            except Exception as e:
                tool_calls_logger.warning(f"INVOKE_ID={invocation_id}: Could not remove temporary script file {script_path}: {e}")

    tool_calls_logger.info(f"INVOKE_ID={invocation_id}: Code execution finished. Status: {status}")
    return {
        "status": status,
        "stdout": stdout_res,
        "stderr": stderr_res,
        "output_files": output_files,
        "metrics": metrics,
        "error_message": error_message if status != "success" else None,
    }

print("--- INSECURE code_execution_tool defined ---")
if not ALLOW_INSECURE_CODE_EXECUTION:
    print("--- WARNING: Insecure code execution tool is currently DISABLED by config.py ---")
else:
    print("--- WARNING: Insecure code execution tool is ENABLED. Use with extreme caution! ---")
